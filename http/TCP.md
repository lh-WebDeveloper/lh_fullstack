# TCP协议
UPD和TCP的区别是什么?

头部:
    Sequence number:该序号保证TCP传输的报文都是有序的,接收端就可以通过顺利拼接报文  (序列号)
    Acknowledgement Number:表示接收端期望接受的下一个字节的编码,同时也表示上一个序号的数据已经接收到了 (确认号)
    Window Size:窗口大小,表示还能接受多少字节的数据,用于流量控制 

# 三次握手
1. 客户端向服务端发送请求报文,客户端会进入SYN-SENT状态
2. 服务端接收到这个请求后如果同意,则发送一个应答,应答发送后便进入SYN-RECEIVED状态
3. 客户端接收到同意的应答后,再向服务端发一个确认报文,客户端进入ESTABLISHED状态,服务端也进入ESTABLISHED状态,此时连接建立成功

# 为什么TCP建立连接需要三次握手,明明两次就可以建立连接

两次:当客户端发送一个连接请求A,因为网络原因A请求超时,TCP就会启动超时重传机制,重新发送连接请求B,
服务端接收到B后进行应答,之后数据传递完成释放连接。
假设此时A在两端关闭之后又到达了服务端,那么此时服务端就会认为客户端又需要建立连接,于是去响应并进入
ESTABLISHED状态,但是客户端已经CLOSED状态,服务端就会一直等,造成资源浪费。

# 四次挥手
1. 客户端认为数据发送完成,向服务端发送释放连接的请求
2. 服务端接收到释放连接的请求后,告诉应用层该释放TCP连接,然后向客户端发送ACK包进入
CLOSE_WAIT 状态。表示不再接受客户端的数据了,但是因为TCP是双向连接,服务端还能向客户端发送数据
3. 如果服务端此时还有没发完的数据就会继续发送,完毕后向客户端发送连接释放请求,自己进入LAST-ACK状态
4. 客户端接收到服务端的释放请求,向服务端确认应答,自己进入TIME-WAIT状态 2ms后就进入CLOSED状态
服务端在接收到这个应答后也进入CLOSED状态


# 为什么客户端要进入TIME-WAIT状态,等待2ms时间后才进入CLOSED状态?
为了保证服务端能够接收到客户端的确认应答,如果客户端确认应答后直接进入CLOSED转态,万一网络问题导致应答
没有被服务端接收到,那么会造成服务端无法关闭。

# 半连接队列和 SYN Flood 攻击是什么关系？
三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：
半连接队列和全连接队列，即SYN队列和ACCEPT队列。

# 半连接队列
当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，
状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。

# 全连接队列
当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，
在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。

# SYN Flood 攻击原理
SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，
就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:
    - 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。
    - 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。

# 如何应对 SYN Flood 攻击？
增加 SYN 连接，也就是增加半连接队列的容量。
减少 SYN + ACK 重试次数，避免大量的超时重发。
利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，
连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。